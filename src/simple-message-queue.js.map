{"version":3,"file":"simple-message-queue.js","sources":["simple-message-queue.ts"],"sourcesContent":["/*\n  A simpe messages queue for IBM's Node-Red\n  https://github.com/shady2k/node-red-contrib-simple-message-queue\n  (c) 2017, shady2k <shady2k@gmail.com>\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n  http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport {\n  Node,\n  NodeAPI,\n  NodeContext,\n  NodeDef,\n  NodeMessageInFlow,\n} from \"node-red\";\n\ninterface nodeConfig extends NodeDef {\n  firstMessageBypass: boolean;\n  backupMessages: boolean;\n  bypassInterval: number;\n  maxMsgLimit: number;\n}\n\ninterface nodeMsg extends NodeMessageInFlow {\n  _queueCount?: number; // Stores the Current Queue Count of Msgs\n  queueCount?: boolean; // Flag to set QueueCount in  messages or not\n  reset?:boolean; // Reset the queue\n  bypassInterval?: string;  // \n  bypass?: boolean;\n  trigger?: boolean;\n  req_failed?: boolean;\n  _queuetimestamp?: any; // Will be time stamp\n  ttl?: string;\n}\n\ninterface nodeContext extends Partial<NodeContext> {\n  queue: nodeMsg[];\n  backup_queue?: nodeMsg[];\n  is_disabled?: boolean;\n  capacity?: number;\n}\n\nmodule.exports = function (RED: NodeAPI) {\n  function isNormalInteger(str: string) {\n    return /^\\+?(0|[1-9]\\d*)$/.test(str);\n  }\n\n  function setBusyFalse(smq: any) {\n    clearTimeout(smq.bypassTimer);\n    smq.bypassTimer = null;\n    smq.isBusy = false;\n  }\n\n  function bypassQueue(smq: any, context: nodeContext, node: Node) {\n    if (\n      smq.bypassInterval > 0 &&\n      context.queue.length > 0 &&\n      !smq.bypassTimer\n    ) {\n      smq.bypassTimer = setTimeout(function bypassSend() {\n        smq.bypassTimer = null;\n        let m = context.queue.shift();\n        if (m) {\n          m[\"_queueCount\"] = context.queue.length;\n          node.send([m, null]);\n\n          if (context.queue.length == 0) {\n            smq.isBusy = false;\n          }\n\n          if (context.queue.length > 0) {\n            smq.bypassTimer = setTimeout(bypassSend, smq.bypassInterval);\n          }\n\n          // Update status\n          node.status({\n            fill: \"green\",\n            shape: \"ring\",\n            text: `${context.queue.length}`,\n          });\n        } else {\n          smq.bypassTimer = null;\n          smq.isBusy = false;\n        }\n      }, smq.bypassInterval);\n    }\n  }\n\n  function stopBypassTimer(smq: any) {\n    clearTimeout(smq.bypassTimer);\n    smq.bypassTimer = null;\n  }\n\n  function SimpleMessageQueueNode(this: Node, config: nodeConfig) {\n    RED.nodes.createNode(this, config);\n    let smq = {\n      firstMessageBypass: config.firstMessageBypass || false,\n      bypassInterval: config.bypassInterval || 0,\n      backupMessages: config.backupMessages || false,\n      maxMsgLimit: config.maxMsgLimit || 0,\n      isBusy: false,\n      bypassTimer: null,\n    };\n    var node = this;\n\n    // Yes it's true: an incoming message just happened\n\n    this.on(\"input\", function (msg: nodeMsg, nodeSend, nodeDone) {\n      let now = Date.now;\n\n      let context = node.context() as nodeContext;\n\n      // if queue doesn't exist, create it\n      context.queue = context.queue || [];\n      context.backup_queue = context.backup_queue || [];\n      context.is_disabled = context.is_disabled || false;\n      context.capacity = smq.maxMsgLimit;\n\n      // if the msg is a reset, clear queue\n      if (msg.reset !== undefined) {\n        context.queue = [];\n        context.backup_queue = [];\n        setBusyFalse(smq);\n      } else if (msg.queueCount !== undefined) {\n        msg[\"_queueCount\"] = context.queue.length;\n        node.send([msg, null]);\n        // } else if (msg.hasOwnProperty(\"set_capacity\")) {\n        // \tcontext.capacity = msg.set_capacity;\n        // \tnode.send([msg,null]);\n      } else if (msg.bypassInterval !== undefined) {\n        let re = /^\\+?(0|[1-9]\\d*)$/;\n        if (re.test(msg.bypassInterval)) {\n          smq.bypassInterval = +msg.bypassInterval; //convert from string to number\n        }\n      } else if (msg.bypass !== undefined) {\n        if (msg.bypass) {\n          context.is_disabled = true;\n        } else {\n          context.is_disabled = false;\n          setBusyFalse(smq);\n          //context.queue = [];\n        }\n      } else if (msg.req_failed !== undefined) {\n        // Push 1 backup msg into main queue again\n        // console.log(context.backup_queue)\n        let last_elem = context.backup_queue.shift();\n        if (last_elem) {\n          context.queue.push(last_elem);\n        } else {\n          return nodeDone();\n        }\n      } else if (msg.trigger !== undefined) {\n        // if the msg is a trigger one release next message\n        // Filter overdue messages\n        context.queue = context.queue.filter(function (x) {\n          if (x.ttl) return now() - x._queuetimestamp < +x.ttl || +x.ttl == 0;\n          return true;\n        });\n\n        let last_elem = context.queue.shift();\n        if (last_elem) {\n          if (smq.backupMessages) context.backup_queue.push(last_elem);\n          last_elem[\"_queueCount\"] = context.queue.length;\n\n          node.send([last_elem, null]);\n          stopBypassTimer(smq);\n          bypassQueue(smq, context, node);\n        } else {\n          setBusyFalse(smq);\n        }\n      } else {\n        if (context.is_disabled || (smq.firstMessageBypass && !smq.isBusy)) {\n          smq.isBusy = true;\n          msg[\"_queueCount\"] = context.queue.length;\n          node.send([msg, null]);\n          stopBypassTimer(smq);\n          bypassQueue(smq, context, node);\n        } else {\n          if (\n            context.capacity <= context.queue.length &&\n            context.capacity > 0\n          ) {\n            // 0 means no limit\n            node.status({\n              fill: \"yellow\",\n              shape: \"ring\",\n              text: `${context.queue.length}`,\n            });\n            nodeSend([null, msg]);\n            return nodeDone();\n          }\n\n          // Check if ttl value of new message is positive integer\n          if (msg.ttl) {\n            if (!isNormalInteger(msg.ttl)) msg.ttl = \"0\";\n          }\n          msg._queuetimestamp = now();\n          context.queue.push(msg); // Add to queue\n\n          // Filter overdue messages\n          context.queue = context.queue.filter(function (x) {\n            if (x.ttl) return now() - x._queuetimestamp < +x.ttl || +x.ttl == 0;\n            return true;\n          });\n        }\n      }\n      console.log(\"Reached\");\n      bypassQueue(smq, context, node);\n      // Update status\n      node.status({\n        fill: \"green\",\n        shape: \"ring\",\n        text: `${context.queue.length}`,\n      });\n      // nodeSend(msg)\n      nodeDone();\n    });\n\n    this.on(\"close\", function () {\n      // Update status\n      node.status({ fill: \"green\", shape: \"ring\", text: \"0\" });\n    });\n  }\n\n  RED.nodes.registerType(\"cgpl-queue\", SimpleMessageQueueNode);\n};\n"],"names":["module","exports","RED","setBusyFalse","smq","clearTimeout","bypassTimer","isBusy","bypassQueue","context","node","bypassInterval","queue","length","setTimeout","bypassSend","m","shift","send","status","fill","shape","text","concat","stopBypassTimer","nodes","registerType","config","createNode","this","firstMessageBypass","backupMessages","maxMsgLimit","on","msg","nodeSend","nodeDone","str","now","Date","backup_queue","is_disabled","capacity","undefined","reset","queueCount","test","bypass","req_failed","last_elem","push","trigger","filter","x","ttl","_queuetimestamp","console","log"],"mappings":"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"}